/**
 * ax-templates CLI - Init Command
 * Initialize a new ax-templates project
 */

import { Command } from 'commander';
import chalk from 'chalk';
import ora from 'ora';
import boxen from 'boxen';
import { existsSync, mkdirSync, writeFileSync, copyFileSync, readdirSync } from 'node:fs';
import { join, resolve, dirname } from 'node:path';
import { stringify as yamlStringify } from 'yaml';
import { fileURLToPath } from 'node:url';
import {
  CONFIG_FILENAME,
  DEFAULT_STAGES,
  createInitialProgress,
  type AxConfig,
} from '@ax-templates/core';
import { runInitWizard, answersToConfig, getQuickInitConfig } from '../prompts/init-wizard.js';

// Get the directory of this file
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

export const initCommand = new Command('init')
  .description('Initialize a new ax-templates project')
  .argument('[project-name]', 'Project name')
  .option('-y, --yes', 'Skip prompts and use defaults')
  .option('--template <name>', 'Template to use', 'default')
  .action(async (projectName?: string, options?: { yes?: boolean; template?: string }) => {
    await executeInit(projectName, options);
  });

async function executeInit(
  projectName?: string,
  options: { yes?: boolean; template?: string } = {}
) {
  console.log();
  console.log(chalk.cyan.bold('ğŸš€ ax-templates í”„ë¡œì íŠ¸ ì´ˆê¸°í™”'));
  console.log();

  // Determine target directory
  const targetDir = projectName ? resolve(process.cwd(), projectName) : process.cwd();

  // Check if directory exists with config
  if (existsSync(join(targetDir, CONFIG_FILENAME))) {
    console.log(chalk.yellow('âš ï¸  ì´ ë””ë ‰í† ë¦¬ì— ì´ë¯¸ ax-templates í”„ë¡œì íŠ¸ê°€ ìˆìŠµë‹ˆë‹¤.'));
    console.log(chalk.gray(`   ${join(targetDir, CONFIG_FILENAME)}`));
    return;
  }

  // Get configuration
  let config: Partial<AxConfig>;

  if (options.yes) {
    // Quick init with defaults
    const name = projectName || 'my-project';
    config = getQuickInitConfig(name);
    console.log(chalk.gray('ê¸°ë³¸ ì„¤ì •ìœ¼ë¡œ ì´ˆê¸°í™”í•©ë‹ˆë‹¤...'));
  } else {
    // Run interactive wizard
    const answers = await runInitWizard(projectName);
    config = answersToConfig(answers);
  }

  // Create project structure
  const spinner = ora('í”„ë¡œì íŠ¸ êµ¬ì¡° ìƒì„± ì¤‘...').start();

  try {
    // Create target directory if needed
    if (!existsSync(targetDir)) {
      mkdirSync(targetDir, { recursive: true });
    }

    // Create directories
    const dirs = [
      config.paths!.stages_output!,
      config.paths!.state!,
      config.paths!.checkpoints!,
      join(config.paths!.state!, 'context'),
      join(config.paths!.state!, 'handoffs'),
    ];

    for (const dir of dirs) {
      const fullPath = join(targetDir, dir);
      if (!existsSync(fullPath)) {
        mkdirSync(fullPath, { recursive: true });
      }
    }

    spinner.succeed('ë””ë ‰í† ë¦¬ êµ¬ì¡° ìƒì„±ë¨');

    // Create config file
    spinner.start('.ax-config.yaml ìƒì„± ì¤‘...');
    const configPath = join(targetDir, CONFIG_FILENAME);
    const configContent = yamlStringify(config, { indent: 2 });
    writeFileSync(configPath, `# ax-templates Configuration\n# Generated by ax init\n\n${configContent}`);
    spinner.succeed('.ax-config.yaml ìƒì„±ë¨');

    // Create stages from template
    spinner.start('ìŠ¤í…Œì´ì§€ í…œí”Œë¦¿ ë³µì‚¬ ì¤‘...');
    await copyStageTemplates(targetDir, config.paths!.stages_output!, options.template || 'default');
    spinner.succeed('ìŠ¤í…Œì´ì§€ í…œí”Œë¦¿ ë³µì‚¬ë¨');

    // Initialize progress.json
    spinner.start('progress.json ì´ˆê¸°í™” ì¤‘...');
    const progressPath = join(targetDir, config.paths!.state!, 'progress.json');
    const initialProgress = createInitialProgress();
    writeFileSync(progressPath, JSON.stringify(initialProgress, null, 2));
    spinner.succeed('progress.json ì´ˆê¸°í™”ë¨');

    // Create CLAUDE.md
    spinner.start('CLAUDE.md ìƒì„± ì¤‘...');
    await createClaudeMd(targetDir, config);
    spinner.succeed('CLAUDE.md ìƒì„±ë¨');

    // Copy config directory
    spinner.start('ì„¤ì • íŒŒì¼ ë³µì‚¬ ì¤‘...');
    await copyConfigFiles(targetDir);
    spinner.succeed('ì„¤ì • íŒŒì¼ ë³µì‚¬ë¨');

    // Copy scripts
    spinner.start('ìŠ¤í¬ë¦½íŠ¸ ë³µì‚¬ ì¤‘...');
    await copyScripts(targetDir);
    spinner.succeed('ìŠ¤í¬ë¦½íŠ¸ ë³µì‚¬ë¨');

    console.log();

    // Success message
    const successMessage = boxen(
      `${chalk.green.bold('âœ“ í”„ë¡œì íŠ¸ê°€ ì„±ê³µì ìœ¼ë¡œ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤!')}\n\n` +
      `${chalk.gray('ë‹¤ìŒ ë‹¨ê³„:')}\n` +
      `${chalk.white('1.')} ${chalk.cyan('stages/01-brainstorm/inputs/project_brief.md')} í¸ì§‘\n` +
      `${chalk.white('2.')} ${chalk.cyan('ax brainstorm')} ì‹¤í–‰\n\n` +
      `${chalk.gray('ë„ì›€ë§:')} ${chalk.cyan('ax --help')}`,
      {
        padding: 1,
        margin: 1,
        borderStyle: 'round',
        borderColor: 'green',
      }
    );

    console.log(successMessage);

  } catch (error) {
    spinner.fail('ì´ˆê¸°í™” ì‹¤íŒ¨');
    console.error(chalk.red('ì˜¤ë¥˜:'), error instanceof Error ? error.message : error);
    process.exit(1);
  }
}

async function copyStageTemplates(
  targetDir: string,
  stagesOutput: string,
  template: string
): Promise<void> {
  // For each default stage, create the directory structure
  for (const stage of DEFAULT_STAGES) {
    const stageDir = join(targetDir, stagesOutput, stage.id);

    // Create directories
    mkdirSync(join(stageDir, 'inputs'), { recursive: true });
    mkdirSync(join(stageDir, 'outputs'), { recursive: true });
    mkdirSync(join(stageDir, 'prompts'), { recursive: true });
    mkdirSync(join(stageDir, 'templates'), { recursive: true });

    // Create stage config.yaml
    const stageConfig = {
      stage: {
        id: stage.id,
        name: stage.name,
        description: stage.description,
      },
      execution: {
        models: stage.models,
        mode: stage.mode,
        timeout: stage.timeout,
        checkpoint_required: stage.checkpoint_required ?? false,
      },
      io: {
        inputs: stage.inputs,
        outputs: stage.outputs,
      },
    };

    writeFileSync(
      join(stageDir, 'config.yaml'),
      yamlStringify(stageConfig, { indent: 2 })
    );

    // Create stage CLAUDE.md
    const claudeMd = `# ${stage.name}

> ìŠ¤í…Œì´ì§€ ID: ${stage.id}
> ëª¨ë¸: ${stage.models.join(', ')}
> ëª¨ë“œ: ${stage.mode}

## ê°œìš”

${stage.description}

## ì…ë ¥

${stage.inputs.map(i => `- \`${i}\``).join('\n')}

## ì¶œë ¥

${stage.outputs.map(o => `- \`${o}\``).join('\n')}

## ì§€ì¹¨

(ì´ ìŠ¤í…Œì´ì§€ì˜ êµ¬ì²´ì ì¸ ì§€ì¹¨ì„ ì‘ì„±í•˜ì„¸ìš”)
`;

    writeFileSync(join(stageDir, 'CLAUDE.md'), claudeMd);

    // Create README.md
    const readme = `# ${stage.name}

${stage.description}

## ì‹¤í–‰ ë°©ë²•

\`\`\`bash
ax ${stage.id.split('-')[1]} # or ax run-stage ${stage.id}
\`\`\`

## ì…ë ¥ íŒŒì¼

${stage.inputs.map(i => `- \`inputs/${i}\``).join('\n')}

## ì¶œë ¥ íŒŒì¼

${stage.outputs.map(o => `- \`outputs/${o}\``).join('\n')}
`;

    writeFileSync(join(stageDir, 'README.md'), readme);

    // Create input placeholder files for first stage
    if (stage.id === '01-brainstorm') {
      const projectBrief = `# Project Brief

## í”„ë¡œì íŠ¸ ì´ë¦„

(í”„ë¡œì íŠ¸ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”)

## í”„ë¡œì íŠ¸ ì„¤ëª…

(í”„ë¡œì íŠ¸ ì„¤ëª…ì„ ì…ë ¥í•˜ì„¸ìš”)

## ëª©í‘œ

- (ëª©í‘œ 1)
- (ëª©í‘œ 2)
- (ëª©í‘œ 3)

## ëŒ€ìƒ ì‚¬ìš©ì

(ëŒ€ìƒ ì‚¬ìš©ìë¥¼ ì„¤ëª…í•˜ì„¸ìš”)

## ê¸°ìˆ  ì œì•½ ì¡°ê±´

(ìˆë‹¤ë©´ ê¸°ìˆ  ì œì•½ ì¡°ê±´ì„ ë‚˜ì—´í•˜ì„¸ìš”)
`;
      writeFileSync(join(stageDir, 'inputs', 'project_brief.md'), projectBrief);

      const userRequirements = `# User Requirements

## ê¸°ëŠ¥ ìš”êµ¬ì‚¬í•­

### í•„ìˆ˜ ê¸°ëŠ¥
- (í•„ìˆ˜ ê¸°ëŠ¥ 1)
- (í•„ìˆ˜ ê¸°ëŠ¥ 2)

### ì„ íƒ ê¸°ëŠ¥
- (ì„ íƒ ê¸°ëŠ¥ 1)

## ë¹„ê¸°ëŠ¥ ìš”êµ¬ì‚¬í•­

- ì„±ëŠ¥:
- ë³´ì•ˆ:
- í™•ì¥ì„±:

## ìš°ì„ ìˆœìœ„

1. (ìµœìš°ì„  í•­ëª©)
2. (ë‘ ë²ˆì§¸ í•­ëª©)
3. (ì„¸ ë²ˆì§¸ í•­ëª©)
`;
      writeFileSync(join(stageDir, 'inputs', 'user_requirements.md'), userRequirements);
    }
  }
}

async function createClaudeMd(targetDir: string, config: Partial<AxConfig>): Promise<void> {
  const claudeMd = `# ax-templates - Multi-AI Workflow Pipeline

10ë‹¨ê³„ ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œ ì›Œí¬í”Œë¡œìš° í…œí”Œë¦¿ ì‹œìŠ¤í…œ

## í”„ë¡œì íŠ¸ ì„¤ì •

> ì„¤ì • íŒŒì¼: \`.ax-config.yaml\`

### ê²½ë¡œ ì„¤ì •
- ì†ŒìŠ¤ì½”ë“œ: \`${config.paths?.project_root}\`
- ìŠ¤í…Œì´ì§€ ì‚°ì¶œë¬¼: \`${config.paths?.stages_output}\`
- ìƒíƒœ íŒŒì¼: \`${config.paths?.state}\`

### AI CLI
- Gemini: ${config.ai?.gemini ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'}
- Codex: ${config.ai?.codex ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'}

### ì»¨í…ìŠ¤íŠ¸ ì„ê³„ê°’
- ê²½ê³ : ${config.context?.warning}%
- ì•¡ì…˜: ${config.context?.action}%
- í¬ë¦¬í‹°ì»¬: ${config.context?.critical}%

## íŒŒì´í”„ë¼ì¸ ê°œìš”

| ë‹¨ê³„ | ì´ë¦„ | AI ëª¨ë¸ | ì‹¤í–‰ ëª¨ë“œ |
|------|------|---------|-----------|
| 01 | Brainstorming | Gemini + ClaudeCode | YOLO (Container) |
| 02 | Research | Claude | Plan Mode |
| 03 | Planning | Gemini | Plan Mode |
| 04 | UI/UX Planning | Gemini | Plan Mode |
| 05 | Task Management | ClaudeCode | Plan Mode |
| 06 | Implementation | ClaudeCode | Plan + Sandbox |
| 07 | Refactoring | Codex | Deep Dive |
| 08 | QA | ClaudeCode | Plan + Sandbox |
| 09 | Testing & E2E | Codex | Sandbox + Playwright |
| 10 | CI/CD & Deployment | ClaudeCode | Headless |

## ìŠ¬ë˜ì‹œ ì»¤ë§¨ë“œ

| ì»¤ë§¨ë“œ | ì„¤ëª… |
|--------|------|
| \`/init-project\` | ìƒˆ í”„ë¡œì íŠ¸ ì´ˆê¸°í™” |
| \`/run-stage [id]\` | íŠ¹ì • ìŠ¤í…Œì´ì§€ ì‹¤í–‰ |
| \`/handoff\` | í˜„ì¬ ìŠ¤í…Œì´ì§€ HANDOFF.md ìƒì„± |
| \`/checkpoint\` | ì²´í¬í¬ì¸íŠ¸ ìƒì„± |
| \`/status\` | íŒŒì´í”„ë¼ì¸ ì „ì²´ ìƒíƒœ í™•ì¸ |
| \`/stages\` | ìŠ¤í…Œì´ì§€ ëª©ë¡ ë° ìƒì„¸ |
| \`/context\` | ì»¨í…ìŠ¤íŠ¸(í† í°) ìƒíƒœ ê´€ë¦¬ |
| \`/next\` | ë‹¤ìŒ ìŠ¤í…Œì´ì§€ë¡œ ì „í™˜ |
| \`/restore\` | ì²´í¬í¬ì¸íŠ¸ì—ì„œ ë³µêµ¬ |

## ê¸ˆì§€ ì‚¬í•­

- HANDOFF.md ì—†ì´ ìŠ¤í…Œì´ì§€ ì „í™˜
- ì²´í¬í¬ì¸íŠ¸ ì—†ì´ íŒŒê´´ì  ì‘ì—… (êµ¬í˜„/ë¦¬íŒ©í† ë§)
- ë‹¨ì¼ ì„¸ì…˜ì— ë³µìˆ˜ ìŠ¤í…Œì´ì§€ í˜¼í•©
- ì´ì „ ìŠ¤í…Œì´ì§€ outputs ìˆ˜ì •
`;

  writeFileSync(join(targetDir, 'CLAUDE.md'), claudeMd);
}

async function copyConfigFiles(targetDir: string): Promise<void> {
  const configDir = join(targetDir, 'config');
  if (!existsSync(configDir)) {
    mkdirSync(configDir, { recursive: true });
  }

  // Create pipeline.yaml
  const pipelineConfig = {
    pipeline: {
      name: 'Multi-AI Development Workflow',
      version: '1.0.0',
      description: '10-stage software development workflow with multi-AI orchestration',
    },
    stages: DEFAULT_STAGES,
    state_management: {
      progress_file: 'state/progress.json',
      checkpoints_dir: 'state/checkpoints',
      context_dir: 'state/context',
      handoffs_dir: 'state/handoffs',
    },
  };

  writeFileSync(
    join(configDir, 'pipeline.yaml'),
    yamlStringify(pipelineConfig, { indent: 2 })
  );

  // Create models.yaml
  const modelsConfig = {
    models: {
      claudecode: {
        provider: 'anthropic',
        model_id: 'claude-sonnet-4-20250514',
        description: 'Primary coding agent with tool use',
      },
      claude: {
        provider: 'anthropic',
        model_id: 'claude-sonnet-4-20250514',
        description: 'Research and analysis specialist',
      },
      gemini: {
        provider: 'google',
        cli_command: 'gemini',
        description: 'Brainstorming and creative planning',
      },
      codex: {
        provider: 'openai',
        cli_command: 'codex',
        description: 'Code optimization and refactoring',
      },
    },
  };

  writeFileSync(
    join(configDir, 'models.yaml'),
    yamlStringify(modelsConfig, { indent: 2 })
  );
}

async function copyScripts(targetDir: string): Promise<void> {
  const scriptsDir = join(targetDir, 'scripts');
  if (!existsSync(scriptsDir)) {
    mkdirSync(scriptsDir, { recursive: true });
  }

  // Create gemini-wrapper.sh
  const geminiWrapper = `#!/bin/bash
# gemini-wrapper.sh - tmux ê¸°ë°˜ Gemini CLI ë˜í¼

SESSION_NAME="\${AX_GEMINI_SESSION:-ax-gemini}"
CHANNEL="ax-gemini-done-\$\$"
OUTPUT_FILE="/tmp/ax-gemini-output-\$\$"
PROMPT="\$1"
TIMEOUT="\${2:-300}"

if [ -z "\$PROMPT" ]; then
    echo "ì‚¬ìš©ë²•: \$0 \\"<prompt>\\" [timeout_seconds]"
    exit 1
fi

if ! command -v tmux &> /dev/null; then
    echo "ì˜¤ë¥˜: tmuxê°€ ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤."
    exit 1
fi

if ! command -v gemini &> /dev/null; then
    echo "ê²½ê³ : gemini CLIê°€ ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤."
    exit 0
fi

cleanup() { rm -f "\$OUTPUT_FILE"; }
trap cleanup EXIT

if ! tmux has-session -t "\$SESSION_NAME" 2>/dev/null; then
    tmux new-session -d -s "\$SESSION_NAME"
    sleep 1
fi

ESCAPED_PROMPT=\$(printf '%s' "\$PROMPT" | sed 's/"/\\\\"/g')
tmux send-keys -t "\$SESSION_NAME" "gemini \\"\$ESCAPED_PROMPT\\" 2>&1 | tee \$OUTPUT_FILE; tmux wait-for -S \$CHANNEL" Enter

(sleep "\$TIMEOUT" && tmux wait-for -S "\$CHANNEL" 2>/dev/null) &
TIMER_PID=\$!
tmux wait-for "\$CHANNEL"
kill \$TIMER_PID 2>/dev/null || true

if [[ -f "\$OUTPUT_FILE" ]]; then
    cat "\$OUTPUT_FILE"
else
    echo "ì˜¤ë¥˜: ì¶œë ¥ì„ ìº¡ì²˜í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤."
    exit 1
fi
`;

  writeFileSync(join(scriptsDir, 'gemini-wrapper.sh'), geminiWrapper, { mode: 0o755 });

  // Create codex-wrapper.sh
  const codexWrapper = `#!/bin/bash
# codex-wrapper.sh - tmux ê¸°ë°˜ Codex CLI ë˜í¼

SESSION_NAME="\${AX_CODEX_SESSION:-ax-codex}"
CHANNEL="ax-codex-done-\$\$"
OUTPUT_FILE="/tmp/ax-codex-output-\$\$"
PROMPT="\$1"
TIMEOUT="\${2:-300}"

if [ -z "\$PROMPT" ]; then
    echo "ì‚¬ìš©ë²•: \$0 \\"<prompt>\\" [timeout_seconds]"
    exit 1
fi

if ! command -v tmux &> /dev/null; then
    echo "ì˜¤ë¥˜: tmuxê°€ ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤."
    exit 1
fi

if ! command -v codex &> /dev/null; then
    echo "ê²½ê³ : codex CLIê°€ ì„¤ì¹˜ë˜ì–´ ìˆì§€ ì•ŠìŠµë‹ˆë‹¤."
    exit 0
fi

cleanup() { rm -f "\$OUTPUT_FILE"; }
trap cleanup EXIT

if ! tmux has-session -t "\$SESSION_NAME" 2>/dev/null; then
    tmux new-session -d -s "\$SESSION_NAME"
    sleep 1
fi

ESCAPED_PROMPT=\$(printf '%s' "\$PROMPT" | sed 's/"/\\\\"/g')
tmux send-keys -t "\$SESSION_NAME" "codex \\"\$ESCAPED_PROMPT\\" 2>&1 | tee \$OUTPUT_FILE; tmux wait-for -S \$CHANNEL" Enter

(sleep "\$TIMEOUT" && tmux wait-for -S "\$CHANNEL" 2>/dev/null) &
TIMER_PID=\$!
tmux wait-for "\$CHANNEL"
kill \$TIMER_PID 2>/dev/null || true

if [[ -f "\$OUTPUT_FILE" ]]; then
    cat "\$OUTPUT_FILE"
else
    echo "ì˜¤ë¥˜: ì¶œë ¥ì„ ìº¡ì²˜í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤."
    exit 1
fi
`;

  writeFileSync(join(scriptsDir, 'codex-wrapper.sh'), codexWrapper, { mode: 0o755 });
}
